## 2022 Project 2

### Εκφώνηση

Άσκηση 1 (20%)
Στο αρχείο modules/UsingADTSet/set_utils.c υπάρχει ο κορμός της γενικής υλοποίησης του set_utils. Η υλοποίηση αυτή θα πρέπει να δουλεύει για οποιοδήποτε ADT Set (πχ για Set βασισμένο σε BST ή BTree), χωρίς να γνωρίζει την ακριβή δομή υλοποίησης του Set.

Στο αρχείο αυτό, υλοποιήστε αρχικά τις παρακάτω λειτουργίες:
```
// Δημιουργεί και επιστρέφει ένα Set που περιέχει όλα τα στοιχεία του
// Vector vec, με διάταξη compare.
// (Διπλά στοιχεία αντιμετωπίζονται ως συνήθως, κάθε εισαγωγή
//  αφαιρεί το προηγούμενο από το set.)

Set set_from_vector(Vector vec, CompareFunc compare);

// Δημιουργεί και επιστρέφει ένα Vector που περιέχει όλα τα στοιχεία
// του set με τη σειρά διάταξης.

Vector set_to_vector(Set set);
```
Όλες οι συναρτήσεις έχουν εξαιρετικά απλή υλοποίηση, χρησομοποιώντας τις αντίστοιχες λειτουργίες του ADT Set.

Στο αρχείο tests/set_utils_test.c υπάρχει ο κορμός ενός test για το set_utils module. Το αντίστοιχο Makefile έχει ρυθμιστεί ώστε να παράγει 2 εκτελέσιμα που τεστάρουν τη γενική υλοποίηση:

UsingADTSet_BST_set_utils_test: test της γενικής υλοποίησης, χρησιμοποιώντας Set βασισμένο σε BST.
UsingADTSet_BTree_set_utils_test: test της γενικής υλοποίησης, χρησιμοποιώντας Set βασισμένο σε BTree.
Στο αρχείο tests/set_utils_test.c προσθέστε tests για τις δύο λειτουργίες που υλοποιήσατε. Όλα τα tests θα πρέπει να περνάνε χωρίς leaks και για τις δύο υλοποιήσεις του ADT Set.

Τέλος στο README.md αναφέρετε την πολυπλοκότητα κάθε λειτουργίας, η οποία εξαρτάται από την υλοποίηση του ADT Set.

Άσκηση 2 (20%)
Ολοκληρώστε τη γενική υλοποίηση στο modules/UsingADTSet/set_utils.c προσθέτωντας τις υπόλοιπες τρεις λειτουργίες:
```
// Καλεί τη συνάρτηση f(set, value) σε κάθε στοιχείο του set με τη σειρά
// διάταξης. Για απλότητα, θεωρούμε ότι η f δεν μεταβάλλει το set (δεν
// προσθέτει ή αφαιρεί στοιχεία).

void set_traverse(Set set, TraverseFunc f);

// Δημιουργεί και επιστρέφει ένα set που περιέχει τα στοιχεία και
// των δύο Sets set1, set2. Τα αρχικά sets δεν μεταβάλλονται.
// (Διπλά στοιχεία αντιμετωπίζονται ως συνήθως, κάθε εισαγωγή
//  αφαιρεί το προηγούμενο από το set.)
//
// Τα δύο Set οφείλουν να έχουν την ίδια διάταξη με τη συνάρτηση compare,
// αλλιώς η συμπεριφορά είναι μη ορισμένη.

Set set_merge(Set set1, Set set2, CompareFunc compare);

// Επιστρέφει την k-οστή τιμή του set με τη σειρά διάταξης, δηλαδή
// το μικρότερο στοιχείο αν k == 0, το δεύτερο μικρότερο αν k == 1,
// κλπ. Η συμπεριφορά είναι μη ορισμένη αν k >= set size.

Pointer set_find_k_smallest(Set set, int k);
```
Στη συνέχεια προσθέστε tests για τις λειτουργίες αυτές στο tests/set_utils_test.c. Όλα τα tests θα πρέπει να περνάνε χωρίς leaks και για τις δύο υλοποιήσεις του ADT Set.

Τέλος στο README.md αναφέρετε την πολυπλοκότητα κάθε λειτουργίας, η οποία εξαρτάται από την υλοποίηση του ADT Set.

Άσκηση 3 (20%)
Η υλοποίηση που φτιάξαμε έχει το πλεονέκτημα ότι δουλεύει για οποιοδήποτε ADT Set (πχ Set βασισμένο σε BST ή BTree). Αλλά έχει το μειονέκτημα ότι σε κάποιες περιπτώσεις είναι μη βέλτιστη (αφού δεν μπορεί να εκμεταλλευτεί τις ιδιαιτερότητες της κάθε δομής).

Στη συνέχεια θα δημιουργήσουμε μια ειδική υλοποίηση για Set βασισμένα σε BST, η οποία θα γνωρίζει την ακριβή δομή του Set και θα μπορεί να τη χρησιμοποιήσει ώστε να βελτιώσει την πολυπλοκότητα των λειτουργιών. Ο κορμός της υλοποίησης αυτής υπάρχει στο αρχείο modules/UsingBinarySearchTree/set_utils.c, στο οποίο υπάρχουν και οι δηλώσεις των structs του BST ώστε να μπορούμε να έχουμε πρόσβαση στη δομή του BST.

Υλοποιήστε αρχικά τις λειτουργίες set_to_vector και set_traverse, οι οποίες θα πρέπει να εκτελούνται σε χρόνο 
.

Το Makefile των tests έχει ρυθμιστεί ώστε να παράγει το εκτελέσιμο UsingBinarySearchTree_set_utils κάνοντας link το tests/set_utils_test.c με την ειδική υλοποίηση του set_utils. Ως συνήθως, όλες οι λειτουργίες θα πρέπει να περνάνε το test χωρίς leaks.

Άσκηση 4 (20%)
Συνεχίζοντας την ειδική υλοποίηση, προσθέστε τη λειτουργία set_from_vector, με τις παρακάτω σημαντικές ιδιότητες:

Η υλοποίηση θα πρέπει πάντα να παράγει balanced δέντρο (με ύψος 
).
Η υλοποίηση θα πρέπει να τρέχει σε 
 όταν η πλειοψηφία των στοιχείων του Vector βρίσκονται ήδη στη σωστή διάταξη (αν όχι και πάλι θα πρέπει να δουλεύει, αλλά με χειρότερη πολυπλοκότητα).
Αυτό μπορεί να υλοποιηθεί ως εξής:

Αρχικά απομονώνουμε τα στοιχεία που βρίσκονται σε λάθος διάταξη, και τα ταξινομούμε (αυτό γίνεται γρήγορα αν ο αριθμός των στοιχείων είναι μικρός).
Ενσωμετώνουμε τα στοιχεία που ταξινομήσαμε στα υπόλοιπα που ήταν ήδη ταξινομημένα, ώστε να έχουμε όλα τα στοιχεία σε σωστή διάταξη.
Τέλος δημιουργούμε σε 
 ένα δέντρο από τα ταξινομημένα στοιχεία
(σκεφτείτε τον αλγόριθμο, είναι απλός, και περιγράψτε τον στο README).
Τέλος υλοποιήστε τη set_merge η οποία θα πρέπει να τρέχει σε χρόνο 
, όπου 
 ο αριθμός στοιχείων των set1, set2 αντίστοιχα.

Όλες οι λειτουργίες θα πρέπει να περνάνε το test χωρίς leaks.

Άσκηση 5 (20%)
Προσθέστε την τελευταία λειτουργία set_find_k_smallest της ειδικής υλοποίησης, η οποία θα πρέπει να εκτελείται σε 
, όπου 
 το ύψος του δέντρου, χωρίς να εξαρτάται από το 
.

Για να το πετύχετε αυτό μπορείτε αν θέλετε να τροποποιήσετε τη δομή του BST, υπό την προϋπόθεση φυσικά ότι όλες οι λειτουργίες του Set θα πρέπει να εξακολουθούν να λειτουργούν (με τις ίδιες πολυπλοκότητες).

Η υλοποίηση θα πρέπει να περνάει το test χωρίς leaks.

Bonus 1 (5%):

Το παίρνετε αν ο κώδικας της set_to_vector είναι πανομοιότυπος στη γενική και την ειδική υλοποίηση, και το ίδιο συμβαίνει και για τη set_merge (και φυσικά οι πολυπλοκότητες παραμένουν σωστές). Δηλαδή θέλουμε κώδικα ο οποίος να είναι ταυτόχρονα γενικός, και να δίνει βέλτιστη πολυπλοκότητα στην ειδική υλοποίηση.

Bonus 2 (10%):

Προσθέστε μια ειδική υλοποίηση modules/UsingBTree/set_utils.c του set_utils module για Set βασισμένα σε BTree. Προσαρμόστε το Makefile των tests ώστε να ελέγχει την υλοποίηση αυτή. Περιγράψτε τέλος στο README τις πολυπλοκότητες των λειτουργικών, που θα πρέπει να είναι βέλτιστες.


### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- Άσκηση 1
- Άσκηση 2 
- Άσκηση 3 (νεοι φακελος στο programs directory για το vector_benchmark και το queue_benchmark)
- Άσκηση 4 (νεος φακελος στο programs directory, το set_bst_benchmark για το πρωτο bonus + ενας νεος φακελος στα modules UsingBTrees που περιεχει την υλοποιηση ADTSet.c μεσω b-trees για το 2ο bonus) 
- Άσκηση 5 

### Documentation

Ασκηση 1

Ολες οι συναρτησεις ειναι Ο(1) γιατι οι stack και list συναρτησεις που καλουνται απο τις queue ειναι O(1) εκτος απο την queue_front_remove και την queue_destroy που ειναι Ο(n), η πρωτη λογω επαναληψης n στοιχειων, ενω η αλλη λογω επαναληψης για να διαγραφουν ολα τα στοιχεια απο τη λιστα που ειναι η "βαθυτερη" συναρτηση που καλειται. Επισης να σημειωσω οτι η queue_remove_front μου κανει 22 δευτερολεπτα να τρεξει στην συγκεκριμενη υλοποιηση.


Ασκηση 2

Ολα ιδια, απλα στην queue_remove_front κανω επαναληψη για να διαγραψω μονο τα στοιχεια του stack2 οταν χρειαζεται, και δεν χρειαζεται τοσο συχνα οσο στην υλοποιηση με vector, οποτε ειναι πολυ πιο αποδοτικη ακομα και αν η πολυπλοκοτητα ειναι O(n).


Άσκηση 3

Η ασκηση 3 κανονικα, ομως επισης προσθεσα και στην υλοποιηση του vector συναρτηση με τα steps για το bonus.

Για τις γραφικες παραστασεις της queue_benchmark: (Κοκκινη γραμμη: steps. Μπλε γραμμη: n). 

1)Παρατηρουμε οτι οσο αυξανεται το n τα βηματα παραμενουν σταθερα γιατι η υλοποιηση της ουρας μεσω λιστας ειναι O(1) σε συναρτησεις insert και remove.

![queue_benchmark_using_list](https://user-images.githubusercontent.com/100521579/169867349-57376d4f-81d6-47b9-b67e-ec70b4f16201.png)

2)Παρατηρουμε οτι οσο αυξανεται το n, λογω των διαδοχικων insert και remove η κοκκινη γραφικη παρασταση αλλαζει συμπεριφορα συνεχως καθως τα removes αυξανουν τα steps καθε φορα καθως ειναι O(n) πολυπλοκοτητας η συναρτηση remove.
![queue_benchmark_using_stack](https://user-images.githubusercontent.com/100521579/169873704-00f8a934-d134-48ee-baa6-9ddffc87ba70.png)

3)Παρατηρουμε οτι οσο αυξανεται το n, η συμπεριφορα της κοκκινης γραφικης παραστασης αλλαζει μονο οταν η στοιβα 2 ειναι αδεια γιατι στην περιπτωση αυτη η μεταφορα στοιχειων στην remove απο στοιβα 1 σε 2 ειναι O(n) αλλα αμα η στοιβα 2 εχει στοιψεια τοτε η remove εχει O(1) πολυπλοκοτητα γιατι δεν χρειαζεται να γινει μεταφορα. Τα inserts ειναι O(1).
![queue_benchmark_using_stack_alt](https://user-images.githubusercontent.com/100521579/169865427-fd6d8833-89bf-40b0-91b2-119904f87aad.png)

Για το vector_benchmark παρατηρουμε οτι η κοκκινη γραφικη παρασταση αλλαζει συμπεριφορα μονο οταν γινεται η realloc.
![vector_benchmark (1)](https://user-images.githubusercontent.com/100521579/169871822-b3bc6f3d-e19e-4509-8163-a96fbbf1cf22.png)

Για την συγκριση του set_insert με set_create_from_sorted_values: Εχω χρησιμοποιησει την συναρτηση clock για να συγκρινω τους χρονους.
Γραφικη παρασταση δεν μπορω να δημιουργησω γιατι για καποιο λογο μου επιστρεφουν παντα 0 τα steps ενω εχω βαλει την συναρτηση log για να βρισκω τα βηματα της καθε συναρτησης.


Άσκηση 4
Η ασκηση 4 κανονικα. Η συναρτηση βρισκεται κατω απο την set_create μαζι με την αναδρομικη που καλει σε ολες τις υλοποιησεις του set που εχω προσθεσει αυτη τη λειτουργια. Επισης εχω προσθεσει την λειτουργεια set_steps στο αρχειο ADTSet.c του φακελου UsingBinarySearchTree, και την συναρτηση της ασκ 4 στο Set μεσω Β-Tree.


Άσκηση 5
Εχω δημιουργησει μια νεα συναρτηση height κατω απο τα structs και εχω κανει αλλαγες στην set_insert και set_ remove.
