## 2022 Project 2

Εκφώνηση: https://k08.chatzi.org/projects/project2/


### Προσωπικά στοιχεία

__Όνομα__: ΙΩΑΝΝΗΣ ΖΕΡΜΠΙΝΟΣ

__Α.Μ.__: sdi2000053

### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- Άσκηση 1
- Άσκηση 2 
- Άσκηση 3 (νεοι φακελος στο programs directory για το vector_benchmark και το queue_benchmark)
- Άσκηση 4 (νεος φακελος στο programs directory, το set_bst_benchmark για το πρωτο bonus + ενας νεος φακελος στα modules UsingBTrees που περιεχει την υλοποιηση ADTSet.c μεσω b-trees για το 2ο bonus) 
- Άσκηση 5 

### Documentation

Ασκηση 1

Ολες οι συναρτησεις ειναι Ο(1) γιατι οι stack και list συναρτησεις που καλουνται απο τις queue ειναι O(1) εκτος απο την queue_front_remove και την queue_destroy που ειναι Ο(n), η πρωτη λογω επαναληψης n στοιχειων, ενω η αλλη λογω επαναληψης για να διαγραφουν ολα τα στοιχεια απο τη λιστα που ειναι η "βαθυτερη" συναρτηση που καλειται. Επισης να σημειωσω οτι η queue_remove_front μου κανει 22 δευτερολεπτα να τρεξει στην συγκεκριμενη υλοποιηση.


Ασκηση 2

Ολα ιδια, απλα στην queue_remove_front κανω επαναληψη για να διαγραψω μονο τα στοιχεια του stack2 οταν χρειαζεται, και δεν χρειαζεται τοσο συχνα οσο στην υλοποιηση με vector, οποτε ειναι πολυ πιο αποδοτικη ακομα και αν η πολυπλοκοτητα ειναι O(n).


Άσκηση 3

Η ασκηση 3 κανονικα, ομως επισης προσθεσα και στην υλοποιηση του vector συναρτηση με τα steps για το bonus.

Για τις γραφικες παραστασεις της queue_benchmark: (Κοκκινη γραμμη: steps. Μπλε γραμμη: n). 

1)Παρατηρουμε οτι οσο αυξανεται το n τα βηματα παραμενουν σταθερα γιατι η υλοποιηση της ουρας μεσω λιστας ειναι O(1) σε συναρτησεις insert και remove.

![queue_benchmark_using_list](https://user-images.githubusercontent.com/100521579/169867349-57376d4f-81d6-47b9-b67e-ec70b4f16201.png)

2)Παρατηρουμε οτι οσο αυξανεται το n, λογω των διαδοχικων insert και remove η κοκκινη γραφικη παρασταση αλλαζει συμπεριφορα συνεχως καθως τα removes αυξανουν τα steps καθε φορα καθως ειναι O(n) πολυπλοκοτητας η συναρτηση remove.
![queue_benchmark_using_stack](https://user-images.githubusercontent.com/100521579/169873704-00f8a934-d134-48ee-baa6-9ddffc87ba70.png)

3)Παρατηρουμε οτι οσο αυξανεται το n, η συμπεριφορα της κοκκινης γραφικης παραστασης αλλαζει μονο οταν η στοιβα 2 ειναι αδεια γιατι στην περιπτωση αυτη η μεταφορα στοιχειων στην remove απο στοιβα 1 σε 2 ειναι O(n) αλλα αμα η στοιβα 2 εχει στοιψεια τοτε η remove εχει O(1) πολυπλοκοτητα γιατι δεν χρειαζεται να γινει μεταφορα. Τα inserts ειναι O(1).
![queue_benchmark_using_stack_alt](https://user-images.githubusercontent.com/100521579/169865427-fd6d8833-89bf-40b0-91b2-119904f87aad.png)

Για το vector_benchmark παρατηρουμε οτι η κοκκινη γραφικη παρασταση αλλαζει συμπεριφορα μονο οταν γινεται η realloc.
![vector_benchmark (1)](https://user-images.githubusercontent.com/100521579/169871822-b3bc6f3d-e19e-4509-8163-a96fbbf1cf22.png)

Για την συγκριση του set_insert με set_create_from_sorted_values: Εχω χρησιμοποιησει την συναρτηση clock για να συγκρινω τους χρονους.
Γραφικη παρασταση δεν μπορω να δημιουργησω γιατι για καποιο λογο μου επιστρεφουν παντα 0 τα steps ενω εχω βαλει την συναρτηση log για να βρισκω τα βηματα της καθε συναρτησης.


Άσκηση 4
Η ασκηση 4 κανονικα. Η συναρτηση βρισκεται κατω απο την set_create μαζι με την αναδρομικη που καλει σε ολες τις υλοποιησεις του set που εχω προσθεσει αυτη τη λειτουργια. Επισης εχω προσθεσει την λειτουργεια set_steps στο αρχειο ADTSet.c του φακελου UsingBinarySearchTree, και την συναρτηση της ασκ 4 στο Set μεσω Β-Tree.


Άσκηση 5
Εχω δημιουργησει μια νεα συναρτηση height κατω απο τα structs και εχω κανει αλλαγες στην set_insert και set_ remove.
