## 2022 Project 3

### Εκφώνηση

Στο μάθημα είδαμε ότι σε έναν πίανακα κατακερματισμού η real-time πολυπλοκότητα της εισαγωγής είναι 
O(n) (τόσο σε average-case όσο και σε worst-case), γιατί τη στιγμή που ο συντελεστής πληρότητας του πίνακα ξεπεράσει το μέγιστο επιτρεπτό θα χρειαστεί να κάνουμε rehash, το οποίο διπλασιάζει το μέγεθος του πίνακα και αντιγράφει όλα τα στοιχεία. Στην εργασία αυτή καλούμαστε να υλοποιήσουμε την τεχνική του incremental rehash, ώστε να αποφύγουμε τη μαζική αντιγραφή στοιχείων.

Η ιδέα είναι πολύ απλή: διπλασιάζουμε το μέγεθος του πίνακα όπως και στο συνηθισμένο rehash, αλλά αντί να αντιγράψουμε εκεί όλα τα στοιχεία, αντιγράφουμε μόνο τα στοιχεία από τις δύο πρώτες θέσεις του πίνακα (αν υπάρχουν στοιχεία εκεί), και τα υπόλοιπα τα κρατάμε στον παλιό. Στη συνέχεια, στο επόμενο insert αντιγράφουμε τα στοιχεία από τις επόμενες δύο θέσεις, κλπ, ώστε τελικά όλα τα στοιχεία να αντιγραφούν αλλά σταδιακά. Μέχρι να γεμίσει ξανά ο πίνακας εμείς θα έχουμε μεταφέρει όλα τα στοιχεία, και στον επόμενο διπλασιασμό ξενικάμε ξανά.

Αυτό σημαίνει ότι ανά πάσα στιγμή έχουμε στοιχεία σε δύο πίνακες, τον τρέχοντα πίνακα array μεγέθους capacity, και τον παλιό πίνακα old_array μεγέθους old_capacity. Όλες οι λειτουργίες θα πρέπει να λαμβάνουν υπόψη και τους δύο πίνακες, το οποίο είναι απλό: πχ κατά την αναζήτηση ψάχνουμε πρώτα στον έναν πίνακα, και αν δεν βρούμε το στοιχείο ψάχνουμε και στον άλλο. Προσοχή επίσης στην map_next, πρέπει πρώτα τα διασχίσει τον ένα πίνακα και μετά τον άλλο.

Φύσικα όλα αυτά γίνονται “κρυφά από το χρήστη”, όπως σε όλες τις υλοποιήσεις των ADTs. Ο χρήστης βλέπει ένα ADP Map με τις συνηθισμένες λειτουργίες, χωρίς να γνωρίζει τι συμβαίνει από πίσω.

Στον modules/UsingHashTable/ADTMap.c υπάρχει η υλοποίηση του ADT Map με πίνακα κατακερματισμού από το lecture-code, στην οποία έχουν προστεθεί τα πεδία old_table, old_capacity, και έχει αφαιρεθεί η λειτουργία του rehash. Εσείς πρέπει να προσθέσετε τη λειτουργία του incremental rehash, και να τροποποιήσετε τις λειτουργίες κατάλληλα. Μπορείτε φυσικά να προσθέσετε όσα επιπλέον πεδία χρειαστείτε.

Το test είναι ως συνήθως στο tests/ADTMap_test.c, το τρέχετε με make run.

### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- Άσκηση 1
- Άσκηση 2

### Documentation

Άσκηση 1

Real-time, worst-case: Η πολυπλοκοτητα σε αυτην την περιπτωση θα ειναι Ο(n) για την εισαγωγη, γιατι στην worst case περίπτωση με ενα insert θα γινει rehash και θα αντιγραφουν ολες οι τιμες απο τον προηγουμενο πινακα στον διπλασιασμενο. Αμα ειχαμε λιστα αντι για δεντρο, δεν θα αλλαζε κατι στην εισαγωγη.

Real-time, average-case: Η πολυπλοκοτητες εδω θα ειναι Ο(1) γιατι κρατώντας το load_factor κατω απο ενα σημειο θα εχουμε διασπαρτες τιμες με μεσο σταθερο μεγεθος σε καθε container. Οποτε στην εισαγωγη δεν θα χρειαστει να μπει το node στο set ωστε να ειναι O(logn) η πολυπλοκοτητα, και αφου δεν θα εχουν μπει στο set κομβοι, τοτε θα αναζητησουμε σε σταθερο χρονο επισης λογω του σταθερου array. Το ιδιο και στη λιστα.

Amortized-time, worst-case: Η πολυπλοκοτητα εδω θα ειναι O(logn) γιατι στην χειροτερη περιπτωση εχουμε συνεχεια collisions και οι τιμες θα μπουν στο set. Σε λιστα, θα ειχαμε αναζητηση σε Ο(n) γιατι μπορει να ειχαν μαζευτει πολλες τιμες σε ενα container, αλλα εισαγωγη σε Ο(1).

Amortized-time, average-case: Η πολυπλοκοτητα θα ειναι O(1) γιατι οπως αναφερθηκε παραπανω δεν θα εχουμε συχνα collisions ωστε να αρχισουν οι τιμες να μπαινουν στο set για να αργησει λιγο περισσοτερο η εισαγωγη και η αναζητηση, και επισης το rehash δεν θα γινεται αρκετα συχνα ωστε να επηρεαστει η μεση πολυπλοκοτητα. Το ιδιο και με λιστα.


Τεστ που μου αποτυγχανουν λογο καποιων λιγων test_assert που θα ηταν σωστες χωρις αυτα: 

2 test_assert στην test_insert γραμμες 44,98 και 137(στην 137 συγκεκριμενα μου τρεχει σωστα αν αντι για 1 ειναι 2 σαν να μου προσθετει μια εξτρα τιμη στο size καπου)
1 test_assert στην test_iterate στην γραμμη 275.
1 test_assert στην test_combined στην γραμμη 318.
                            

Σημείωση: Ειχα προσθεσει καποια test_assert στην test_simple_remove του ADTMap_test.c για δοκιμες και καταλαθος τα εκανα commit γι αυτο φαινεται να εχω κανει commit, αλλα μετα τα ξαναεφτιαξα οπως ηταν στην αρχη.


Άσκηση 2


Τεστ που μου αποτυγχανουν λογο καποιων λιγων test_assert που θα ηταν σωστες χωρις αυτα: 

1 test_assert στην test_simple_remove γραμμη 156.
